<!DOCTYPE html>
<html lang=en>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>同步和锁 | aidodoo</title>
  <meta name="description" content="同步和锁本系列文章主要讲解Java并发相关的内容，包括同步、锁、信号量、阻塞队列、线程池等，整体思维导图如下：目录列表如下：     java并发-基础概念和Thread java并发-同步和锁 java并发工具类1 java并发工具类2 java并发工具类3  本文主要讲解Java内存模型、同步块、重入锁ReentrantLock和读写锁ReentrantReadWriteLock的应用及源码实">
<meta property="og:type" content="article">
<meta property="og:title" content="同步和锁">
<meta property="og:url" content="http://aidodoo.com/java/java%E5%B9%B6%E5%8F%91-%E5%90%8C%E6%AD%A5%E5%92%8C%E9%94%81/index.html">
<meta property="og:site_name" content="aidodoo">
<meta property="og:description" content="同步和锁本系列文章主要讲解Java并发相关的内容，包括同步、锁、信号量、阻塞队列、线程池等，整体思维导图如下：目录列表如下：     java并发-基础概念和Thread java并发-同步和锁 java并发工具类1 java并发工具类2 java并发工具类3  本文主要讲解Java内存模型、同步块、重入锁ReentrantLock和读写锁ReentrantReadWriteLock的应用及源码实">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/aidodoo/blogpic/master/java/concurrent2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/aidodoo/blogpic/master/java/java-memory-model-1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/aidodoo/blogpic/master/java/java-memory-model-2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/aidodoo/blogpic/master/java/java-memory-model-4.png">
<meta property="og:image" content="https://raw.githubusercontent.com/aidodoo/blogpic/master/java/java-memory-model-5.png">
<meta property="og:image" content="https://raw.githubusercontent.com/aidodoo/blogpic/master/java/Lock.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/aidodoo/blogpic/master/java/ReentrantLock.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/aidodoo/blogpic/master/java/ReentrantLock_AQS.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/aidodoo/blogpic/master/java/CAS.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/aidodoo/blogpic/master/java/ReadWriterStructure.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/aidodoo/blogpic/master/sqm/sqm.jpg">
<meta property="article:published_time" content="2016-04-03T00:00:00.000Z">
<meta property="article:modified_time" content="2019-06-11T11:54:37.000Z">
<meta property="article:author" content="aidodoo">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/aidodoo/blogpic/master/java/concurrent2.png">
  <!-- Canonical links -->
  <link rel="canonical" href="http://aidodoo.com/java/java%E5%B9%B6%E5%8F%91-%E5%90%8C%E6%AD%A5%E5%92%8C%E9%94%81/index.html">
  
    <link rel="alternate" href="/atom.xml" title="aidodoo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/aidodoo" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">aidodoo</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Java Developer</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> ShangHai, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form" method="GET" action="https://www.baidu.com/s?">
	<div class="input-group">
    	<input name="wd" type="text" class="form-control search-form-input" placeholder="Search" />
	    <span class="input-group-btn">
	    	<button type="submit" class=" btn btn-flat search-form-submit"><i class="icon icon-search"></i></button>
	    </span>
    </div>
</form>

</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">Home</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">Archives</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">Categories</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">Tags</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">Repository</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-books">
          <a href="/books">
            
            <i class="icon icon-book-fill"></i>
            
            <span class="menu-title">Books</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">Links</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">About</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/aidodoo" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com/aidodoo" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">Board</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      

    
      
  <div class="widget">
    <h3 class="widget-title">Tags</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/hadoop/" rel="tag">hadoop</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hbase/" rel="tag">hbase</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kafka/" rel="tag">kafka</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/others/" rel="tag">others</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spark/" rel="tag">spark</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/zookeeper/" rel="tag">zookeeper</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/hadoop/" style="font-size: 13px;">hadoop</a> <a href="/tags/hbase/" style="font-size: 13px;">hbase</a> <a href="/tags/java/" style="font-size: 13.5px;">java</a> <a href="/tags/kafka/" style="font-size: 14px;">kafka</a> <a href="/tags/others/" style="font-size: 13.5px;">others</a> <a href="/tags/spark/" style="font-size: 13px;">spark</a> <a href="/tags/zookeeper/" style="font-size: 13px;">zookeeper</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">Archive</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04/">April 2014</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/others/%E8%99%9A%E6%8B%9F%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85/" class="title">(no title)</a>
              </p>
              <p class="item-date">
                <time datetime="2021-07-21T07:30:01.946Z" itemprop="datePublished">2021-07-21</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/others/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="title">(no title)</a>
              </p>
              <p class="item-date">
                <time datetime="2021-07-21T07:30:01.931Z" itemprop="datePublished">2021-07-21</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/others/python%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="title">(no title)</a>
              </p>
              <p class="item-date">
                <time datetime="2021-07-21T07:30:01.931Z" itemprop="datePublished">2021-07-21</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/others/pinpoint%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="title">pinpoint底层存储数据结构</a>
              </p>
              <p class="item-date">
                <time datetime="2019-06-07T00:00:00.000Z" itemprop="datePublished">2019-06-07</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/others/spark%E9%9B%86%E7%BE%A4%E7%9A%84%E6%90%AD%E5%BB%BA/" class="title">spark集群的搭建</a>
              </p>
              <p class="item-date">
                <time datetime="2019-06-06T00:00:00.000Z" itemprop="datePublished">2019-06-06</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<main class="main" role="main">
  <div class="content">
  <article id="post-java/java并发-同步和锁" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      同步和锁
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/java/java%E5%B9%B6%E5%8F%91-%E5%90%8C%E6%AD%A5%E5%92%8C%E9%94%81/" class="article-date">
	  <time datetime="2016-04-03T00:00:00.000Z" itemprop="datePublished">2016-04-03</time>
	</a>
</span>
        
        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/java/" rel="tag">java</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/java/java%E5%B9%B6%E5%8F%91-%E5%90%8C%E6%AD%A5%E5%92%8C%E9%94%81/#comments" class="article-comment-link">Comments</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="同步和锁"><a href="#同步和锁" class="headerlink" title="同步和锁"></a>同步和锁</h1><p>本系列文章主要讲解Java并发相关的内容，包括同步、锁、信号量、阻塞队列、线程池等，整体思维导图如下：<br><img src="https://raw.githubusercontent.com/aidodoo/blogpic/master/java/concurrent2.png"><br>目录列表如下：   </p>
<ul>
<li><a href="https://aidodoo.com/post/java/java%E5%B9%B6%E5%8F%91-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%92%8CThread/">java并发-基础概念和Thread</a></li>
<li><a href="https://aidodoo.com/post/java/java%E5%B9%B6%E5%8F%91-%E5%90%8C%E6%AD%A5%E5%92%8C%E9%94%81/">java并发-同步和锁</a></li>
<li><a href="https://aidodoo.com/post/java/java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB1/">java并发工具类1</a></li>
<li><a href="https://aidodoo.com/post/java/java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB2/">java并发工具类2</a></li>
<li><a href="https://aidodoo.com/post/java/java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB3/">java并发工具类3</a></li>
</ul>
<p>本文主要讲解Java内存模型、同步块、重入锁<code>ReentrantLock</code>和读写锁<code>ReentrantReadWriteLock</code>的应用及源码实现。</p>
<p>我们之所以要用多线程并发，是为了更好地利用服务器资源，使程序的响应速度更好。然而，如果多个线程访问了相同的资源，如同一内存区的变量、数组和对象，以及外部数据库或者文件等，可能导致程序的运行结果和我们预期的不一致。<br>假设你家庭成员都用同一个银行账户，每天都有收入或者支出，我们来看如下的代码：   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.molyeo.java.concurrent;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zhangkh on 2018/8/24.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Account account=<span class="keyword">new</span> Account();</span><br><span class="line">        account.setBalance(<span class="number">100000</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;Account : Initial Balance: %f\n&quot;</span>,account.getBalance());</span><br><span class="line"></span><br><span class="line">        Spender spender=<span class="keyword">new</span> Spender(account);</span><br><span class="line">        Thread spenderThread=<span class="keyword">new</span> Thread(spender);</span><br><span class="line">        spenderThread.start();</span><br><span class="line"></span><br><span class="line">        Earner earner=<span class="keyword">new</span> Earner(account);</span><br><span class="line">        Thread earnerThread=<span class="keyword">new</span> Thread(earner);</span><br><span class="line">        earnerThread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            spenderThread.join();</span><br><span class="line">            earnerThread.join();</span><br><span class="line">            System.out.printf(<span class="string">&quot;Account : Final Balance: %f\n&quot;</span>,account.getBalance());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SynchronizedDemo</code>类先创建一个账户，然后将账户实例传递给<code>Spender</code>线程(每个月花钱的败家子)和<code>Earner</code>线程(挣钱养家的家庭成员)，然后启动这两个线程。<br>其中<code>Account</code>的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBalance</span><span class="params">(<span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAmount</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        balance=balance+amount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subtractAmount</span><span class="params">(<span class="keyword">double</span> amount)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        balance=balance-amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Account</code>拥有一个成员变量<code>balance</code>,用于记录账户余额，对外提供一个增加余额<code>addAmount()</code>和减少余额<code>subtractAmount()</code>的方法。<br><code>Spender</code>和<code>Earner</code>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spender</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Spender</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.account=account;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">30</span>; i++)&#123;</span><br><span class="line">            account.subtractAmount(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Earner</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Earner</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.account=account;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">30</span>; i++)&#123;</span><br><span class="line">            account.addAmount(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Spender</code>线程每个月花钱<code>30</code>次，每次花<code>1000</code>人民币；<code>Earner</code>线程挣钱<code>30</code>次，每次挣<code>1000</code>人民币。<br><code>SynchronizedDemo</code>程序中先设置账户余额为<code>10</code>万元，可以认为是家庭存款，按照预期的结果，这个月败家子花了<code>3</code>万，养家的爸妈一起挣了<code>3</code>万，这个月后结算，家里存款还是<code>10</code>万。虽然爸妈这个月白忙了，但是败家子还是先别内疚了，先看看程序的输出。</p>
<p>第一次运行输出结果如下(由于有一定的随机性，结果不一定完全相同)：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Account : Initial Balance: <span class="number">100000.000000</span></span><br><span class="line">Account : Final Balance: <span class="number">99000.000000</span></span><br></pre></td></tr></table></figure>

<p>第二次运行输出结果如下(由于有一定的随机性，结果不一定完全相同)：   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Account : Initial Balance: <span class="number">100000.000000</span></span><br><span class="line">Account : Final Balance: <span class="number">112000.000000</span></span><br></pre></td></tr></table></figure>

<p>程序到底怎么了呢，好好地每次运行结果还不一致了？要深入分析这个问题，我们要先了解下<code>Java</code>的内存模型。</p>
<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p><code>Java</code>内存模型规范了<code>Java</code>虚拟机和计算机内存的协同工作机制，简单的说就是说明了如何和何时可以看到由其他线程修改后的共享变量的值，以及在必须时如何同步地访问共享变量。</p>
<h3 id="Java内存模型逻辑视图"><a href="#Java内存模型逻辑视图" class="headerlink" title="Java内存模型逻辑视图"></a>Java内存模型逻辑视图</h3><p><code>Java</code>内存模型把<code>Java</code>虚拟机划分为线程栈和堆。<br><img src="https://raw.githubusercontent.com/aidodoo/blogpic/master/java/java-memory-model-1.png"><br>每个运行在<code>Java</code>虚拟机中的线程拥有自己的线程栈，包含线程调用的方法当前执行点相关的信息。同时一个线程也仅仅能访问自己的线程栈，线程创建的本地变量仅自己可见，其他线程不可见。<br>原始类型(<code>boolean</code>, <code>byte</code>, <code>short</code>, <code>char</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>)的本地变量都存放在线程栈上,而<code>Java</code>程序中创建的对象都存在在堆上，不管是自定义的自定义对象，还是原始类型的包装对象(如<code>Byte</code>, <code>Integer</code>, <code>Long</code>等)。下面这张图演示了调用栈和本地变量存放在线程栈上，对象存放在堆上。<br><img src="https://raw.githubusercontent.com/aidodoo/blogpic/master/java/java-memory-model-2.png"><br>变量到底是存放在线程栈上还是堆上，有如下几点说明：   </p>
<ul>
<li>本地变量如果是原始类型，则始终存在线程栈上</li>
<li>本地变量如果是对象的引用，则这个引用存在现在线程栈上，而对象存在堆上</li>
<li>一个对象的方法中的本地变量存在线程栈上，即使这个对象存放在堆上</li>
<li>对象的成员变量和对象本身一起存放在堆上，不管成员变量是原始类型还是引用类型</li>
<li>静态成员变量也是存放在堆上</li>
<li>存放在堆上的对象可以被所有持有对这个对象引用的线程访问。当一个线程可以访问一个对象时，它也可以访问这个对象的成员变量。如果两个线程同时调用同一个对象上的同一个方法，它们将会都访问这个对象的成员变量，但是每一个线程都拥有这个本地变量的私有拷贝。</li>
</ul>
<h3 id="硬件内存架构"><a href="#硬件内存架构" class="headerlink" title="硬件内存架构"></a>硬件内存架构</h3><p>现代硬件内存模型与<code>Java</code>内存模型有一些不同。理解内存模型架构以及<code>Java</code>内存模型如何与它协同工作也是非常重要的。</p>
<p>现代计算机硬件架构简单图示如下：<br><img src="https://raw.githubusercontent.com/aidodoo/blogpic/master/java/java-memory-model-4.png">   </p>
<p>现代计算机通常由两个或者多个<code>CPU</code>组成,拥有寄存器，缓存，和主存，其中访问速度寄存器最高，缓存次之，再者就是主存。<br>通常情况下，当一个<code>CPU</code>需要读取主存时，它会将主存的部分读到<code>CPU</code>缓存中。它甚至可能将缓存中的部分内容读到它的内部寄存器中，然后在寄存器中执行操作。当<code>CPU</code>需要将结果写回到主存中去时，它会将内部寄存器的值刷新到缓存中，然后在某个时间点将值刷新回主存。<br>需要注意的是，当<code>CPU</code>需要在缓存层存放一些东西的时候，存放在缓存中的内容通常会被刷新回主存。<code>CPU</code>缓存可以在某一时刻将数据局部写到它的内存中，和在某一时刻局部刷新它的内存。它不会再某一时刻读/写整个缓存，通常是一个或者多个缓存行被读取或者写入。    </p>
<p>硬件内存架构没有区分线程栈和堆。对于硬件，所有的线程栈和堆都分布在主内中。部分线程栈和堆可能有时候会出现在<code>CPU</code>缓存中和<code>CPU</code>内部的寄存器中。如下图所示：<br><img src="https://raw.githubusercontent.com/aidodoo/blogpic/master/java/java-memory-model-5.png">   </p>
<p>当对象和变量被存放在计算机中各种不同的内存区域中时，就有可能会出现一些问题，主要包括两个方面：  </p>
<ul>
<li>共享变量修改的可见性</li>
<li>多线程读写共享变量时出现竞态条件</li>
</ul>
<p>我们以上面的<code>SynchronizedDemo</code>例子，从硬件内存架构来分析这两个问题。<br><strong>可见性</strong><br><code>Account</code>的成员变量<code>balance</code>被初始化为<code>100000</code>后，保存在主存中。<code>Spender</code>线程首次将这个共享对象读取到缓存后，调用<code>subtractAmount()</code>方法减少了<code>balance</code>的值。如果此时缓存数据没有被刷新到主存，则更改后的值对其他线程是不可见的。<br>而此时<code>Earner</code>线程也将共享对象拷贝到缓存中，注意此时的共享对象的值还是<code>100000</code>，然后调用<code>addAmount()</code>方法增加<code>balance</code>的值。这样两个线程多次更改后，导致最后<code>balance</code>的结果是不确定的，进而出现每次运行的结果可能不太一致。<br>为了解决共享变量的可见性问题，可以使用<code>Java</code>中的<code>volatile</code>关键字，其可以保证直接从主存中读取一个变量，如果这个变量被修改后，总是会被写到主存中去。<br>看到这里后，我们可以尝试对<code>Account</code>的成员变量<code>balance</code>使用<code>volatile</code>修饰，然后多次运行上述程序，看结果是否保持一致。<br><code>Account</code>修改内容如下：   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>  <span class="keyword">volatile</span> <span class="keyword">double</span> balance;</span><br></pre></td></tr></table></figure>

<p>为了避免多次运行，我们在<code>SynchronizedDemo</code>的主程序中，直接循环<code>10</code>次：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            Account account = <span class="keyword">new</span> Account();</span><br><span class="line">            account.setBalance(<span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">            System.out.printf(<span class="string">&quot;Account : Initial Balance: %s\n&quot;</span>,account.getBalance());</span><br><span class="line"></span><br><span class="line">            Spender spender=<span class="keyword">new</span> Spender(account);</span><br><span class="line">            Thread spenderThread=<span class="keyword">new</span> Thread(spender);</span><br><span class="line">            spenderThread.start();</span><br><span class="line"></span><br><span class="line">            Earner earner=<span class="keyword">new</span> Earner(account);</span><br><span class="line">            Thread earnerThread=<span class="keyword">new</span> Thread(earner);</span><br><span class="line">            earnerThread.start();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                spenderThread.join();</span><br><span class="line">                earnerThread.join();</span><br><span class="line">                System.out.printf(<span class="string">&quot;Account : Final Balance: %s\n&quot;</span>,account.getBalance());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;------------------------------------------------------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们来见证奇迹的发生，看看程序的输出结果：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Account : Initial Balance: <span class="number">100000.0</span></span><br><span class="line">Account : Final Balance: <span class="number">105000.0</span></span><br><span class="line">------------------------------------------------------</span><br><span class="line">Account : Initial Balance: <span class="number">100000.0</span></span><br><span class="line">Account : Final Balance: <span class="number">99000.0</span></span><br><span class="line">------------------------------------------------------</span><br><span class="line">Account : Initial Balance: <span class="number">100000.0</span></span><br><span class="line">Account : Final Balance: <span class="number">99000.0</span></span><br><span class="line">------------------------------------------------------</span><br><span class="line">Account : Initial Balance: <span class="number">100000.0</span></span><br><span class="line">Account : Final Balance: <span class="number">100000.0</span></span><br><span class="line">------------------------------------------------------</span><br><span class="line">Account : Initial Balance: <span class="number">100000.0</span></span><br><span class="line">Account : Final Balance: <span class="number">99000.0</span></span><br><span class="line">------------------------------------------------------</span><br><span class="line">Account : Initial Balance: <span class="number">100000.0</span></span><br><span class="line">Account : Final Balance: <span class="number">98000.0</span></span><br><span class="line">------------------------------------------------------</span><br><span class="line">Account : Initial Balance: <span class="number">100000.0</span></span><br><span class="line">Account : Final Balance: <span class="number">96000.0</span></span><br><span class="line">------------------------------------------------------</span><br><span class="line">Account : Initial Balance: <span class="number">100000.0</span></span><br><span class="line">Account : Final Balance: <span class="number">94000.0</span></span><br><span class="line">------------------------------------------------------</span><br><span class="line">Account : Initial Balance: <span class="number">100000.0</span></span><br><span class="line">Account : Final Balance: <span class="number">97000.0</span></span><br><span class="line">------------------------------------------------------</span><br><span class="line">Account : Initial Balance: <span class="number">100000.0</span></span><br><span class="line">Account : Final Balance: <span class="number">98000.0</span></span><br><span class="line">------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>这是怎么回事呢，为什么每次运行的结果不完全一致呢，因为这里还涉及到操作原子性的问题。<br><strong>原子性</strong><br>所谓原子性，即一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。<br>我们来看<code>Account</code>中用于修改余额<code>balance</code>的两个方法：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAmount</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    balance=balance+amount;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subtractAmount</span><span class="params">(<span class="keyword">double</span> amount)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    balance=balance-amount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不管是<code>addAmount</code>还是<code>subtractAmount</code>方法对<code>balance</code>的操作都不具备原子性，其包括读取变量的原始值，进行加法或者减法的操作，然后写入工作内存。<br>假设<code>Account</code>初始值为<code>100000</code>，<code>Earner</code>线程先启动，读取了<code>balance</code>的原始值，还没有对<code>balance</code>进行修改前，这是线程被阻塞了。<br>然后<code>Spender</code>线程后启动，也读取了<code>balance</code>的值，由于该变量还没有被修改，故<code>Spender</code>线程的缓存还是有效的，然后进行减少<code>amount</code>(<code>amount</code>=<code>1000</code>)的操作,操作后<code>balance</code>的值为<code>99000</code>，将其写入工作内存，最后写入到主存。<br>然后<code>Earner</code>线程被激活了，虽然此时<code>Spender</code>线程对<code>balance</code>进行了修改，并使<code>Earner</code>线程中的缓存行无效，但由于<code>Earner</code>线程先前已经得到<code>balance</code>的值了,故<code>balance</code>的值还是先前的<code>100000</code>，继续进行相关的加法操作，操作后的最后<code>balance</code>值为<code>101000</code>，最后将结果写入到主存。此处涉及到<code>Java</code>语言的指令集架构，数据计算时基于栈的，有兴趣的可以去深入研究。<br>在<code>Java</code>中，只有基本数据类型的变量的读取和赋值是原子性操作的，即这些操作是不可中断的，要么执行，要么不执行。<br>如下对<code>long</code>型的<code>balance</code>赋值是原子性的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">balance=<span class="number">100000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但对<code>balance</code>进行算术运算则不是原子性的，因为其包括读取<code>balance</code>的值、加<code>1000</code>、写入新的值等三个操作。   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">balance=balance+<span class="number">1000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果我们要实现更大范围操作的原子性，则需要通过<code>synchronized</code>和<code>Lock</code>来实现。同步块或者锁可以保证同一个时刻仅有一个线程可以进入代码的临界区，同时代码块中所有被访问的变量将会从主存中读入，退出同步块时，不管这个变量本身是否被声明为<code>volatile</code>,所有被更新的变量会被刷新到主存。<br>有了这些理论知识后，我们再看上面的示例如何修改，才能是最终的运行结果正确且完全一致。<br>我们只需要将要在多线程中访问的方法<code>addAmount</code>和<code>subtractAmount</code>声明为<code>synchronized</code>即可。由于<code>synchronized</code>能够保证唯一访问和修改后的数据刷新到主存，则成员变量<code>balance</code>是否被声明为<code>volatile</code>都无所谓了。我们看修改后的<code>Account</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBalance</span><span class="params">(<span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addAmount</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        balance = balance + amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">subtractAmount</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        balance = balance - amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后不管我们运行多少次，都可以看到最后<code>balance</code>的值都是<code>100000</code>。</p>
<h2 id="同步块"><a href="#同步块" class="headerlink" title="同步块"></a>同步块</h2><p><code>Java</code>中同步块主要用来标记方法或者代码块时同步的，同步在同一个对象上的同步块同一时刻只能被一个进程进入并执行相关操作，其他线程被阻塞，直到执行该同步块的线程退出。<br><code>Java</code>中主要要四种不同的同步块：   </p>
<ul>
<li>实例方法</li>
<li>静态方法</li>
<li>实例方法中的同步块</li>
<li>静态方法中的同步块</li>
</ul>
<h3 id="实例方法同步"><a href="#实例方法同步" class="headerlink" title="实例方法同步"></a>实例方法同步</h3><p>我们上面<code>Account</code>类中的两个方法就是实例方法上的同步(去掉线程睡眠的代码)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addAmount</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">    balance = balance + amount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">subtractAmount</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">    balance = balance - amount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>Java</code>实例方法同步是同步在拥有该方法的实例上的，只有一个线程能够在实例方法同步块中运行。如果有多个实例存在，则一个线程一次可以在一个实例同步块中执行操作，但是不同的线程针对不同的实例则是可以同时执行的。<br>###实例方法中的同步<br>有时候不需要同步整个方法，而是方法中的一部分。我们将上面的<code>addAmount()</code>方法改写如下：   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAmount</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">        balance = balance + amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">subtractAmount</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">    balance = balance - amount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上例中，使用了关键字<code>this</code>，即为调用<code>addAmount</code>方法的实例本身。在同步构造器中用括号括起来的对象叫做监视器对象。上述代码使用监视器对象同步，同步实例方法使用调用方法本身的实例作为监视器对象。<br>如果实例方法同步和实例方法中的同步，是针对同一个实例的话，则同一时刻只有一个线程在这两个同步块中的任意一个方法内执行。   </p>
<h3 id="静态方法同步"><a href="#静态方法同步" class="headerlink" title="静态方法同步"></a>静态方法同步</h3><p>静态方法的同步是同步在该方法所在的类对象上的，因为<code>JVM</code>中一个类只能对应一个类对象，故同一时刻只允许一个线程执行同一个类中的静态同步方法。   </p>
<h3 id="静态方法中的同步块"><a href="#静态方法中的同步块" class="headerlink" title="静态方法中的同步块"></a>静态方法中的同步块</h3><p>静态方法中的同步块和静态方法作用类似，都是同步在类对象上。<br>下面的两个静态方法的同步块是不允许同时被线程访问的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addAmount</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        balance = balance + amount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">subtractAmount</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Account.class)&#123;</span><br><span class="line">        balance = balance - amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>上面的章节中，我们深入探讨了线程同步以及同步块的多种形式，但是不是所有被多线程访问方法都需要同步呢？这就需要我们了解代码是到底是不是线程安全的。<br>所谓线程安全，是只允许被多个线程同时执行的代码，其不包含竞态条件。而多个线程同时更新共享资源时会引发竞态条件，因而需要知道<code>Java</code>线程执行时共享了什么资源。</p>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>局部变量存储在线程栈中，即局部变量永远不会被多个线程共享，基础类型的局部变量是线程安全的。如下面的代码，即使多个线程调用，其结果总是返回固定值<code>1</code>。    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">fixedNumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> result=<span class="number">0</span>;</span><br><span class="line">    result++;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="局部的对象引用"><a href="#局部的对象引用" class="headerlink" title="局部的对象引用"></a>局部的对象引用</h3><p>局部的对象引用和局部变量不一样，虽然引用自身存在线程栈上，但是引用所值得对象存在共享堆中。<br>如果这个方法中创建的对象不能逃逸出该方法，即实例不能被别的线程获取到，也不会被非局部变量引用到，则其是线程安全的，否则不是线程安全的。<br>在下面的代码中，我们在<code>makeAccountAndInit</code>方法中新建<code>Account</code>对象，并赋值给<code>account</code>引用。由于<code>account</code>没有被方法<code>makeAccountAndInit</code>返回，也没有被其他的方法返回，故这里的引用<code>account</code>是线程安全的。   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeAccountAndInit</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Account account=<span class="keyword">new</span> Account();</span><br><span class="line">    initBalance(account);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initBalance</span><span class="params">(Account account)</span></span>&#123;</span><br><span class="line">    account.setBalance(<span class="number">100000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是如果<code>account</code>作为结果被返回，则其可以被其他线程获取到，则不是线程安全的。    </p>
<h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>成员变量存储在堆上，如果多个线程同时更新同一个对象的同一个成员，则代码不是线程安全的。就如同我们最开始的<code>SynchronizedDemo</code>例子。<br>至于如何判断我们的代码是否是线程安全的，可以根据线程控制逃逸规则。</p>
<h3 id="线程控制逃逸规则"><a href="#线程控制逃逸规则" class="headerlink" title="线程控制逃逸规则"></a>线程控制逃逸规则</h3><p>如果一个资源的创建、使用、销毁都是在同一个线程内完成的，且永远不会脱离该线程的控制，则该资源的使用就是线程安全的。<br>资源可以是对象，数组，文件，数据库连接，套接字等等。<code>Java</code>中你无需主动销毁对象，所以“销毁”指不再有引用指向对象。<br>此外即使对象本身是线程安全的，但对象中如果包含其他资源，也会导致应用不是线程安全的。<br>如<code>2</code>个线程都创建了各自的数据库连接，每个连接自身是线程安全的，但是如果连接到同一个数据库，并且更新同一行记录，如<code>update</code> <code>table</code> <code>set</code> <code>num</code>=<code>num</code>+<code>1</code> <code>where</code> <code>id</code>=<code>10000</code>;<code>。可能最后的结果并没有增加</code>2<code>，而是只增加</code>1`。<br>因而在实际编程时，一定要注意区分线程控制的对象是资源本身，还是只是资源的引用。</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p><code>Java</code>中锁<code>Lock</code>和<code>synchronized</code>同步块一样，是一种线程同步机制,但提供了更灵活的结构,更细粒度的控制。<br>###Lock和synchronized的区别     </p>
<ul>
<li><p><code>Lock</code>实现类提供了细粒度的控制。<code>synchronized</code>方法或者语句提供了对每个对象相关的隐式监视器锁的访问，但是强制锁的获取和释放均要出现在一个块结构中。而<code>Lock</code>实现类允许锁在不同的作用范围内获取和释放，并允许以任何的顺序获取和释放多个锁。</p>
</li>
<li><p><code>Lock</code>实现类提供了<code>synchronized</code>方法不包含的功能。如获取锁尝试、获取可中断的锁尝试、获得可超时锁的尝试</p>
<p>//仅在调用时锁为空闲状态才获取该锁。    </p>
<pre><code>boolean tryLock(); 
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//如果当前线程未被中断，则获取锁。</span><br><span class="line">void lockInterruptibly() throws InterruptedException;</span><br><span class="line"></span><br><span class="line">//如果锁在给定的等待时间内空闲，并且当前线程未被中断，则获取锁。</span><br><span class="line">boolean tryLock(long time, TimeUnit unit) throws InterruptedException;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><code>Lock</code>实现类提供了更丰富的语义。如保证排序、非重入用法或死锁检测等。</p>
</li>
</ul>
<h3 id="Lock使用示例"><a href="#Lock使用示例" class="headerlink" title="Lock使用示例"></a>Lock使用示例</h3><p>为了演示<code>Lock</code>的使用，我们使用<code>Lock</code>改写之前利用<code>synchronized</code>的<code>SynchronizedDemo</code>,新的程序代码如下：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.molyeo.java.concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zhangkh on 2018/8/27.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            AccountWithLock account = <span class="keyword">new</span> AccountWithLock();</span><br><span class="line">            account.setBalance(<span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">            System.out.printf(<span class="string">&quot;Account : Initial Balance: %s\n&quot;</span>, account.getBalance());</span><br><span class="line">            Spender spender = <span class="keyword">new</span> Spender(account);</span><br><span class="line">            Thread spenderThread = <span class="keyword">new</span> Thread(spender);</span><br><span class="line">            spenderThread.start();</span><br><span class="line"></span><br><span class="line">            Earner earner = <span class="keyword">new</span> Earner(account);</span><br><span class="line">            Thread earnerThread = <span class="keyword">new</span> Thread(earner);</span><br><span class="line">            earnerThread.start();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                spenderThread.join();</span><br><span class="line">                earnerThread.join();</span><br><span class="line">                System.out.printf(<span class="string">&quot;Account : Final Balance: %s\n&quot;</span>, account.getBalance());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;------------------------------------------------------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountWithLock</span> <span class="keyword">extends</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBalance</span><span class="params">(<span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAmount</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            balance = balance + amount;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subtractAmount</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            balance = balance - amount;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>只需要改写<code>Account</code>类，将<code>addAmount()</code>方法和<code>subtractAmount()</code>中采用获取锁，然后操作<code>balance</code>变量，最后释放锁即可。<br>由于<code>setBalance()</code>方法并没有在多个线程中使用，故此处没有改写，实际应用中需要注意。<br>可以看到程序中使用的是<code>Lock</code>的实现类<code>ReentrantLock</code>，即可重入锁。</p>
<h3 id="Lock的类图"><a href="#Lock的类图" class="headerlink" title="Lock的类图"></a>Lock的类图</h3><p><code>Java</code>中主要有<code>Lock</code>和<code>ReadWriteLock</code>(读写锁)这两个接口，其中<code>Lock</code>的实现有可重入锁<code>ReentrantLock</code>、以及<code>ReentrantReadWriteLock</code>(可重入读写锁)的两个子类<code>ReadLock</code>和<code>WriteLock</code>.<br>而接口<code>ReaderWriteLock</code>实现只有<code>ReentrantReadWriteLock</code>(可重入读写锁)。类图如下：   </p>
<p><img src="https://raw.githubusercontent.com/aidodoo/blogpic/master/java/Lock.jpg"></p>
<h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>在上面的示例中我们在类<code>AccountWithLock</code>中使用可重入锁<code>ReentrantLock</code>实现了类似同步块的功能。<br>可以说可重入锁是<code>java</code>.<code>util</code>.<code>concurrent</code>包的基石，众多<code>Java</code>并发工具类将其作为成员变量，以解决多线程的资源共享问题。</p>
<p><img src="https://raw.githubusercontent.com/aidodoo/blogpic/master/java/ReentrantLock.jpg"></p>
<h3 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h3><p>通过查看<code>ReentrantLock</code>的源码，会知道其有三个子类。一个抽象子类<code>Sync</code>，以及<code>Sync</code>的的两个具体类<code>NonfairSync</code>、<code>FairSync</code>。而<code>Sync</code>是又继承了<code>AbstractQueuedSynchronizer</code>。整体类图如下：<br><img src="https://raw.githubusercontent.com/aidodoo/blogpic/master/java/ReentrantLock_AQS.jpg"><br>其中<code>AbstractQueuedSynchronizer</code>简称<code>AQS</code>,为实现依赖于先进先出 (<code>FIFO</code>) 等待队列的阻塞锁和相关同步器（信号量、事件，等等）提供一个框架。<br><strong>AQS和CAS</strong><br><code>AbstractQueuedSynchronizer</code>(简称<code>AQS</code>)有一个成员变量<code>state</code>,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由其子类去完成更改此状态的方法。<br>为了将<code>AQS</code>这个类作为同步器的基础，其子类要重新定义如下几个方法。  </p>
<ul>
<li><code>tryAcquire</code>(<code>int</code>)</li>
<li><code>tryRelease</code>(<code>int</code>)</li>
<li><code>tryAcquireShared</code>(<code>int</code>)</li>
<li><code>tryReleaseShared</code>(<code>int</code>)</li>
<li><code>isHeldExclusively()</code></li>
</ul>
<p>而这<code>5</code>个方法主要是调用<code>AQS</code>的如下三个方法以原子方式去获取或者更新<code>state</code>值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果当前状态值等于预期值，则以原子方式将同步状态设置为给定的更新值。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，从头到尾都没有<code>synchronized</code>关键字，没有使用<code>java</code>中任何锁的机制，而代码能保证多线程时具有线程安全性，所依靠的是<code>Unsafe</code>中的<code>compareAndSwapInt</code>方法。我们最开始提到过，在<code>java</code>中加减法操作不是原子性的，而<code>compareAndSwapInt</code>又是如何保证原子性的？<br>我们看一下<code>Unsafe</code>中这个方法的定义：   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br><span class="line">var2为变量的值</span><br><span class="line">var4为预期的值</span><br><span class="line">var5为更新的值</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到该方法是用<code>native</code>修饰的，即不是通过<code>Java</code>实现的，其借助<code>C</code>语言调用底层的<code>CPU</code>特殊指令实现的，即<code>CAS</code>(<code>CompareAndSwap</code>)指令。<br><code>CAS</code>是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说<code>CAS</code>是一条<code>CPU</code>的原子指令，不会造成所谓的数据不一致问题。<br>指令的操作过程如下：首先，<code>CPU</code> 会将内存中将要被更改的数据与期望的值做比较。当这两个值相等时，说明没有其他线程修改该值，当前线程可以修改，<code>CPU</code> 才会将内存中的数值替换为新的值。否则说明其他线程已经修改过，不执行更新操作，但可以选择重新读取变量值再尝试修改或者直接放弃操作。原理图如下：</p>
<p><img src="https://raw.githubusercontent.com/aidodoo/blogpic/master/java/CAS.jpg">    </p>
<p><code>CAS</code>虽然是很高效的解决原子操作，但也存在一些问题。    </p>
<ul>
<li><code>ABA</code>问题。即值原来是<code>A</code>,然后变成<code>B</code>,又变成<code>A</code>,那么使用<code>CAS</code>检查是其值没有发生变化，但实际上值已经被修改过了。可以采用版本号解决该问题，如利用类<code>AtomicStampedReference</code>。</li>
<li>如果自旋<code>CAS</code>如果长时间不成功，循环时间开销大，会给<code>CPU</code>带来非常大的执行开销，此外程序测试相对复杂。   </li>
</ul>
<h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><p>有<code>CAS</code>的基础知识后，了解了<code>Lock</code>原子性的实现，我们再来看<code>ReentrantLock</code>具体的代码。<br>默认情况下，创建的<code>ReentrantLock</code>是非公平锁  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>公平锁中线程获取锁的顺序和调用<code>lock</code>的顺序医院，<code>FIFO</code>;但为了保证线程规规矩矩排队，需要增加阻塞和唤醒的时间开销，故基于性能考虑，默认情况是非公平锁。<br>在<code>ReentrantLockDemo</code>的例子中，如果<code>Spender</code>和<code>Earner</code>线程同时调用<code>subtractAmount</code>和<code>addAmount</code>方法，进而同时调用<code>lock</code>.<code>lock()</code>，即调用<code>NonfairSync</code>中的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>则两个线程同时尝试去将<code>AbstractQueuedSynchronizer</code>类的<code>state</code>修改为<code>1</code>。如果<code>Spender</code>更改成功，<code>compareAndSetState</code>(<code>0</code>, <code>1</code>)返回为<code>true</code>,则<code>Spender</code>线程获得该锁，完成后<code>state</code>修改为<code>1</code>，并<code>setExclusiveOwnerThread</code>将线程记录为独占锁的线程，然后执行了相关业务操作。</p>
<p>而失败的<code>Earner</code>线程执行<code>acquire</code>(<code>1</code>);<br><code>AbstractQueuedSynchronizer</code>中<code>acquire()</code>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>AQS</code>的<code>tryAcquire</code>不能直接调用，因为是否获取锁成功是由子类决定的，直接看<code>ReentrantLock</code>中内部类<code>NonfairSync</code>的<code>tryAcquire</code>的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">	<span class="comment">//首次获得</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//重入</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果<code>Spender</code>线程获得该锁(包括重入)，通过<code>CAS</code>将<code>state</code>为<code>1</code>，返回为<code>true</code>。如果通过<code>CAS</code>抢占失败，也要去排队。执行<code>acquireQueued</code>(<code>addWaiter</code>(<code>Node</code>.<code>EXCLUSIVE</code>), <code>arg</code>)，加入等待队列中。加入前将线程封装成<code>Node</code>对象，<code>Node</code>主要有三个成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> Node prev;</span><br><span class="line"><span class="keyword">volatile</span> Node next;</span><br><span class="line"><span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>每个<code>Node</code>维护了线程、前后<code>Node</code>的指针和等待状态等参数。<code>Node</code>需要标记是独占的还是共享的，由传入的<code>mode</code>决定，<code>ReentrantLock</code>自然是使用独占模式<code>Node</code>.<code>EXCLUSIVE</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果队列为空，即<code>pred</code>为<code>null</code>,则调用<code>enq</code>(<code>Node</code> <code>node</code>)方法。否则将<code>node</code>包装完成后，调用<code>compareAndSetTail</code>将该<code>node</code>添加到队列最后。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>enq()</code>方法中如果队列为空，先为<code>head</code>创建空<code>node</code>,然后调用<code>compareAndSetHead</code>方法设置到队列头部。后续调用<code>compareAndSetTail</code>将<code>node</code>设置为尾部。外部循环执行，直到设置成功。<br>线程加入队列后，下一步是调用<code>acquireQueued</code>阻塞线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中方法<code>shouldParkAfterFailedAcquire</code>传入当前节点和前节点，根据前节点的状态，判断线程是否需要阻塞。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;   </span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>判断逻辑如下： </p>
<ul>
<li>前节点状态是<code>SIGNAL</code>时，当前线程需要阻塞；    </li>
<li>前节点状态是<code>CANCELLED</code>时，通过循环将当前节点之前所有取消状态的节点移出队列；    </li>
<li>前节点状态是其他状态时，需要设置前节点为<code>SIGNAL</code>。</li>
</ul>
<p>总结一下获取锁的过程：线程去竞争一个锁，可能成功也可能失败。成功就直接持有资源，不需要进入队列；失败的话进入队列阻塞，等待唤醒后再尝试竞争锁。</p>
<h3 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h3><p>释放锁的过程如下：先将<code>state</code>减<code>1</code>，再通知后面的节点获取锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>release</code>方法先调用<code>tryRelease</code>将<code>state</code>减<code>1</code>，直到为<code>0</code>时将独占线程变量设置为空。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">		Node h = head;</span><br><span class="line">		<span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">			unparkSuccessor(h);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">	<span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">	<span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">		free = <span class="keyword">true</span>;</span><br><span class="line">		setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	setState(c);</span><br><span class="line">	<span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置成功后，调用<code>unparkSuccessor</code>将头节点的下个节点唤醒：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><h3 id="基础属性"><a href="#基础属性" class="headerlink" title="基础属性"></a>基础属性</h3><p><code>ReadWriteLock</code>维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。只要没有 <code>writer</code>，读取锁可以由多个 <code>reader</code> 线程同时保持。写入锁是独占的。<br>与互斥锁相比，读-写锁允许对共享数据进行更高级别的并发访问，尤其当数据的读取远大于数据的写入时。<br>读写锁的互斥机制：</p>
<ul>
<li>“读-读” 不互斥</li>
<li>“读-写” 互斥</li>
<li>“写-写” 互斥</li>
</ul>
<p><code>ReentrantReadWriteLock</code>是<code>ReentrantReadWriteLock</code>的实现，该类具有以下属性：</p>
<ul>
<li>获取顺序<br>非公平模式下，不指定读写锁的顺序，可能会推迟一个或者多个<code>reader</code>或者<code>writer</code>线程，但是吞吐量通常高于公平锁。<br>公平模式下，线程利用一个近似到达顺序的策略来争夺进入。当释放当前保持的锁时，可以为等待时间最长的单个 <code>writer</code> 线程分配写入锁，如果有一组等待时间大于所有正在等待的 <code>writer</code> 线程 的 <code>reader</code> 线程，将为该组分配写入锁。</li>
<li>重入<br>此锁允许 <code>reader</code> 和 <code>writer</code> 按照 <code>ReentrantLock</code> 的样式重新获取读取锁或写入锁。在写入线程保持的所有写入锁都已经释放后，才允许重入 <code>reader</code> 使用它们。<br>此外，<code>writer</code> 可以获取读取锁，但反过来则不成立。在其他应用程序中，当在调用或回调那些在读取锁状态下执行读取操作的方法期间保持写入锁时，重入很有用。如果 <code>reader</code> 试图获取写入锁，那么将永远不会获得成功。  </li>
<li>锁降级<br>重入还允许从写入锁降级为读取锁，其实现方式是：先获取写入锁，然后获取读取锁，最后释放写入锁。但是，从读取锁升级到写入锁是不可能的。</li>
<li>中断<br>读取锁和写入锁都支持锁获取期间的中断。</li>
<li><code>Condition</code><br>写入锁提供了一个 <code>Condition</code> 实现，对于写入锁来说，该实现的行为与 <code>ReentrantLock</code>.<code>newCondition()</code> 提供的 <code>Condition</code> 实现对 <code>ReentrantLock</code> 所做的行为相同。当然，此 <code>Condition</code> 只能用于写入锁。<br>读取锁不支持 <code>Condition</code>，<code>readLock()</code>.<code>newCondition()</code> 会抛出 <code>UnsupportedOperationException</code>。</li>
</ul>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>在我们在开始的账户余额管理例子中，针对的是一个账户进行更改，并且基本上都是修改操作。假设我们现在有不同用户的账户需要管理，同时有读取和修改操作，同时读取的线程数较多，这样我们则可以考虑用读写锁来实现。<br>在类<code>WriteReadAccountMap</code>中我们有一个成员变量<code>balanceMap</code>去存储不同账户的余额，同时有<code>ReentrantReadWriteLock</code>实例<code>lock</code>去负责读写时的并发控制： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WriteReadAccountMap</span> </span>&#123;</span><br><span class="line">    Logger logger = LoggerFactory.getLogger(WriteReadAccountMap.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock readLock = lock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock writeLock = lock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Double&gt; balanceMap = <span class="keyword">new</span> TreeMap&lt;String, Double&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">getBalance</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;&#123;&#125; get readLock&quot;</span>, Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Double cacheValue = balanceMap.get(key);</span><br><span class="line">            <span class="keyword">if</span>(cacheValue==<span class="keyword">null</span>)&#123;</span><br><span class="line">                cacheValue=<span class="number">0D</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            logger.info(<span class="string">&quot;&#123;&#125; cacheValue &#123;&#125;&quot;</span>, Thread.currentThread().getName(), cacheValue);</span><br><span class="line">            <span class="keyword">return</span> cacheValue;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">            logger.info(<span class="string">&quot;&#123;&#125; unlock readLock&quot;</span>, Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">setBalance</span><span class="params">(String key, Double value)</span> </span>&#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> balanceMap.put(key, value);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map <span class="title">getMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> balanceMap;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAmount</span><span class="params">(String key, Double value)</span> </span>&#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        logger.info(<span class="string">&quot;&#123;&#125; get writeLock&quot;</span>, Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        readLock.lock();</span><br><span class="line">        logger.info(<span class="string">&quot;&#123;&#125; get readLock&quot;</span>, Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        Double cacheValue = balanceMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (cacheValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            cacheValue = <span class="number">0D</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Double newValue = cacheValue + value;</span><br><span class="line">        logger.info(<span class="string">&quot;&#123;&#125; cacheValue=&#123;&#125;,add value=&#123;&#125;,newValue=&#123;&#125;&quot;</span>, Thread.currentThread().getName(), cacheValue, value, newValue);</span><br><span class="line">        readLock.unlock();</span><br><span class="line">        logger.info(<span class="string">&quot;&#123;&#125; unlock readLock&quot;</span>, Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        balanceMap.put(key, newValue);</span><br><span class="line">        writeLock.unlock();</span><br><span class="line">        logger.info(<span class="string">&quot;&#123;&#125; unlock writeLock&quot;</span>, Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subtractAmount</span><span class="params">(String key, Double value)</span> </span>&#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        readLock.lock();</span><br><span class="line">        Double cacheValue = balanceMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (cacheValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            cacheValue = <span class="number">0D</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Double newValue = cacheValue - value;</span><br><span class="line">        readLock.unlock();</span><br><span class="line"></span><br><span class="line">        balanceMap.put(key, newValue);</span><br><span class="line">        writeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            balanceMap.clear();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到<code>addAmount</code>方法中由于我们要修改账户余额，我们先获得写锁，同时我们也有获得账户缓存余额，然后锁降级，在写锁释放前获得读锁，得到缓存值和新值相加的结果后，释放读锁，最后写入缓存<code>Map</code>，释放写锁。<br>读写线程很简单，<code>Writer</code>线程负责增加<code>my</code>账户的余额，<code>Reader</code>线程负责读取<code>my</code>账户的余额：   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reader</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    Logger logger = LoggerFactory.getLogger(Reader.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> WriteReadAccountMap accountMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Reader</span><span class="params">(WriteReadAccountMap accountMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountMap = accountMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Double accountMapBalance = accountMap.getBalance(<span class="string">&quot;my&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Writer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    Logger logger = LoggerFactory.getLogger(Writer.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> WriteReadAccountMap accountMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Writer</span><span class="params">(WriteReadAccountMap accountMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountMap = accountMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        accountMap.addAmount(<span class="string">&quot;my&quot;</span>, <span class="number">10.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>主程序创建<code>10</code>个<code>Writer</code>线程和<code>30</code>个<code>Reader</code>线程，去完成数据的读写，最后在<code>main</code>线程中获取<code>my</code>账户的余额。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span>  Logger logger = LoggerFactory.getLogger(ReentrantReadWriteLockDemo.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        WriteReadAccountMap account = <span class="keyword">new</span> WriteReadAccountMap();</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Writer writer = <span class="keyword">new</span> Writer(account);</span><br><span class="line">            executorService.submit(writer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            Reader reader = <span class="keyword">new</span> Reader(account);</span><br><span class="line">            executorService.submit(reader);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        logger.info(account.getBalance(<span class="string">&quot;my&quot;</span>).toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>程序部分运行结果如下：   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">18</span>/08/<span class="number">29</span> <span class="number">14</span>:<span class="number">21</span>:<span class="number">39</span> INFO concurrent.WriteReadAccountMap: pool-<span class="number">1</span>-thread-<span class="number">1</span> get writeLock</span><br><span class="line"><span class="number">18</span>/08/<span class="number">29</span> <span class="number">14</span>:<span class="number">21</span>:<span class="number">39</span> INFO concurrent.WriteReadAccountMap: pool-<span class="number">1</span>-thread-<span class="number">1</span> get readLock</span><br><span class="line"><span class="number">18</span>/08/<span class="number">29</span> <span class="number">14</span>:<span class="number">21</span>:<span class="number">39</span> INFO concurrent.WriteReadAccountMap: pool-<span class="number">1</span>-thread-<span class="number">11</span> get readLock</span><br><span class="line"><span class="number">18</span>/08/<span class="number">29</span> <span class="number">14</span>:<span class="number">21</span>:<span class="number">39</span> INFO concurrent.WriteReadAccountMap: pool-<span class="number">1</span>-thread-<span class="number">12</span> get readLock</span><br><span class="line"><span class="number">18</span>/08/<span class="number">29</span> <span class="number">14</span>:<span class="number">21</span>:<span class="number">39</span> INFO concurrent.WriteReadAccountMap: pool-<span class="number">1</span>-thread-<span class="number">13</span> get readLock</span><br><span class="line"><span class="number">18</span>/08/<span class="number">29</span> <span class="number">14</span>:<span class="number">21</span>:<span class="number">39</span> INFO concurrent.WriteReadAccountMap: pool-<span class="number">1</span>-thread-<span class="number">1</span> cacheValue=<span class="number">0.0</span>,add value=<span class="number">10.0</span>,newValue=<span class="number">10.0</span></span><br><span class="line"><span class="number">18</span>/08/<span class="number">29</span> <span class="number">14</span>:<span class="number">21</span>:<span class="number">39</span> INFO concurrent.WriteReadAccountMap: pool-<span class="number">1</span>-thread-<span class="number">1</span> unlock readLock</span><br><span class="line"><span class="number">18</span>/08/<span class="number">29</span> <span class="number">14</span>:<span class="number">21</span>:<span class="number">39</span> INFO concurrent.WriteReadAccountMap: pool-<span class="number">1</span>-thread-<span class="number">1</span> unlock writeLock</span><br><span class="line"><span class="number">18</span>/08/<span class="number">29</span> <span class="number">14</span>:<span class="number">21</span>:<span class="number">39</span> INFO concurrent.WriteReadAccountMap: pool-<span class="number">1</span>-thread-<span class="number">2</span> get writeLock</span><br><span class="line"><span class="number">18</span>/08/<span class="number">29</span> <span class="number">14</span>:<span class="number">21</span>:<span class="number">39</span> INFO concurrent.WriteReadAccountMap: pool-<span class="number">1</span>-thread-<span class="number">1</span> get readLock</span><br><span class="line"><span class="number">18</span>/08/<span class="number">29</span> <span class="number">14</span>:<span class="number">21</span>:<span class="number">39</span> INFO concurrent.WriteReadAccountMap: pool-<span class="number">1</span>-thread-<span class="number">2</span> get readLock</span><br><span class="line"><span class="number">18</span>/08/<span class="number">29</span> <span class="number">14</span>:<span class="number">21</span>:<span class="number">39</span> INFO concurrent.WriteReadAccountMap: pool-<span class="number">1</span>-thread-<span class="number">2</span> cacheValue=<span class="number">10.0</span>,add value=<span class="number">10.0</span>,newValue=<span class="number">20.0</span></span><br><span class="line"><span class="number">18</span>/08/<span class="number">29</span> <span class="number">14</span>:<span class="number">21</span>:<span class="number">39</span> INFO concurrent.WriteReadAccountMap: pool-<span class="number">1</span>-thread-<span class="number">2</span> unlock readLock</span><br><span class="line"><span class="number">18</span>/08/<span class="number">29</span> <span class="number">14</span>:<span class="number">21</span>:<span class="number">39</span> INFO concurrent.WriteReadAccountMap: pool-<span class="number">1</span>-thread-<span class="number">2</span> unlock writeLock</span><br><span class="line"><span class="number">18</span>/08/<span class="number">29</span> <span class="number">14</span>:<span class="number">21</span>:<span class="number">39</span> INFO concurrent.WriteReadAccountMap: pool-<span class="number">1</span>-thread-<span class="number">2</span> get readLock</span><br><span class="line"><span class="number">18</span>/08/<span class="number">29</span> <span class="number">14</span>:<span class="number">21</span>:<span class="number">39</span> INFO concurrent.WriteReadAccountMap: pool-<span class="number">1</span>-thread-<span class="number">3</span> get writeLock</span><br><span class="line"><span class="number">18</span>/08/<span class="number">29</span> <span class="number">14</span>:<span class="number">21</span>:<span class="number">39</span> INFO concurrent.WriteReadAccountMap: pool-<span class="number">1</span>-thread-<span class="number">3</span> get readLock</span><br><span class="line"><span class="number">18</span>/08/<span class="number">29</span> <span class="number">14</span>:<span class="number">21</span>:<span class="number">39</span> INFO concurrent.WriteReadAccountMap: pool-<span class="number">1</span>-thread-<span class="number">3</span> cacheValue=<span class="number">20.0</span>,add value=<span class="number">10.0</span>,newValue=<span class="number">30.0</span></span><br><span class="line"><span class="number">18</span>/08/<span class="number">29</span> <span class="number">14</span>:<span class="number">21</span>:<span class="number">39</span> INFO concurrent.WriteReadAccountMap: pool-<span class="number">1</span>-thread-<span class="number">3</span> unlock readLock</span><br><span class="line"><span class="number">18</span>/08/<span class="number">29</span> <span class="number">14</span>:<span class="number">21</span>:<span class="number">39</span> INFO concurrent.WriteReadAccountMap: pool-<span class="number">1</span>-thread-<span class="number">3</span> unlock writeLock</span><br><span class="line"><span class="number">18</span>/08/<span class="number">29</span> <span class="number">14</span>:<span class="number">21</span>:<span class="number">39</span> INFO concurrent.WriteReadAccountMap: pool-<span class="number">1</span>-thread-<span class="number">3</span> get readLock</span><br><span class="line"><span class="number">18</span>/08/<span class="number">29</span> <span class="number">14</span>:<span class="number">21</span>:<span class="number">39</span> INFO concurrent.WriteReadAccountMap: pool-<span class="number">1</span>-thread-<span class="number">4</span> get writeLock</span><br><span class="line"><span class="number">18</span>/08/<span class="number">29</span> <span class="number">14</span>:<span class="number">21</span>:<span class="number">39</span> INFO concurrent.WriteReadAccountMap: pool-<span class="number">1</span>-thread-<span class="number">4</span> get readLock</span><br><span class="line"><span class="number">18</span>/08/<span class="number">29</span> <span class="number">14</span>:<span class="number">21</span>:<span class="number">39</span> INFO concurrent.WriteReadAccountMap: pool-<span class="number">1</span>-thread-<span class="number">4</span> cacheValue=<span class="number">30.0</span>,add value=<span class="number">10.0</span>,newValue=<span class="number">40.0</span></span><br><span class="line"><span class="number">18</span>/08/<span class="number">29</span> <span class="number">14</span>:<span class="number">21</span>:<span class="number">39</span> INFO concurrent.WriteReadAccountMap: pool-<span class="number">1</span>-thread-<span class="number">4</span> unlock readLock</span><br><span class="line"><span class="number">18</span>/08/<span class="number">29</span> <span class="number">14</span>:<span class="number">21</span>:<span class="number">39</span> INFO concurrent.WriteReadAccountMap: pool-<span class="number">1</span>-thread-<span class="number">4</span> unlock writeLock</span><br><span class="line"><span class="number">18</span>/08/<span class="number">29</span> <span class="number">14</span>:<span class="number">21</span>:<span class="number">39</span> INFO concurrent.WriteReadAccountMap: pool-<span class="number">1</span>-thread-<span class="number">5</span> get writeLock</span><br><span class="line"><span class="number">18</span>/08/<span class="number">29</span> <span class="number">14</span>:<span class="number">21</span>:<span class="number">39</span> INFO concurrent.WriteReadAccountMap: pool-<span class="number">1</span>-thread-<span class="number">5</span> get readLock</span><br><span class="line"><span class="number">18</span>/08/<span class="number">29</span> <span class="number">14</span>:<span class="number">21</span>:<span class="number">39</span> INFO concurrent.WriteReadAccountMap: pool-<span class="number">1</span>-thread-<span class="number">5</span> cacheValue=<span class="number">40.0</span>,add value=<span class="number">10.0</span>,newValue=<span class="number">50.0</span></span><br><span class="line">....</span><br><span class="line"><span class="number">18</span>/08/<span class="number">29</span> <span class="number">14</span>:<span class="number">21</span>:<span class="number">44</span> INFO concurrent.ReentrantReadWriteLockDemo: <span class="number">100.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从输出日志我们也能看到账户余额一次从<code>0</code>累加到<code>100</code>，符合我们的预期结果。</p>
<h3 id="源码实现-1"><a href="#源码实现-1" class="headerlink" title="源码实现"></a>源码实现</h3><p>下面简单我们分析一下<code>ReentrantReadWriteLock</code>的源码实现。<br><strong>整体结构和锁状态维护</strong>    </p>
<p><code>ReentrantReadWriteLock</code>整体结构如下： </p>
<p><img src="https://raw.githubusercontent.com/aidodoo/blogpic/master/java/ReadWriterStructure.jpg"></p>
<p>读写锁比<code>ReentrantLock</code>多出了两个内部类：<code>ReadLock</code>和<code>WriteLock</code>， 用来定义读锁和写锁，然后在构造函数中，会构造一个读锁和一个写锁实例保存到成员变量 <code>readerLock</code> 和 <code>writerLock</code>。    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</span><br><span class="line">    writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在互斥锁<code>ReentrantLock</code>中我们利用<code>AQS</code>中的<code>state</code>字段去维护锁的状态，但是读写锁<code>ReentrantReadWriteLock</code>也是利用<code>AQS</code>,而其是如何用一个变量去维护两个内部锁的状态的呢？<br>这里要看一下<code>AQS</code>的实现类<code>Sync</code>的定义，<code>Sync</code>有如下<code>4</code>个成员变量和两个静态方法：   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns the number of shared holds represented in count  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line"><span class="comment">/** Returns the number of exclusive holds represented in count  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们知道<code>AQS</code>中的<code>state</code>是<code>int</code>类型的，即<code>32</code>位的。<br>在读写锁中，读锁是共享的，写锁是独占的。从上面的读写锁用其高<code>16</code>位表示占用读锁的线程数，低<code>16</code>位表示写锁的状态。   </p>
<ul>
<li>获取共享锁数量时，调用<code>sharedCount()</code>方法，直接将<code>state</code>无符号右移<code>16</code>位，得到高<code>16</code>位的值。</li>
<li>获取独占锁数量时，调用<code>exclusiveCount()</code>方法，将其和<code>65535</code>(<code>upper16</code>=<code>0000000000000000</code>,<code>lower16</code>=<code>1111111111111111</code>)按位与运算后，高<code>16</code>位全部为<code>0</code>，后<code>16</code>位即<code>state</code>的低<code>16</code>位。</li>
</ul>
<p>还不明白运算规则的可以用下面的这个例子去琢磨   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.molyeo.java.concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zhangkh on 2018/8/29.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiftOperationsDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span>  Logger logger = LoggerFactory.getLogger(ShiftOperationsDemo.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        formatPrintInt(EXCLUSIVE_MASK);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> state=<span class="number">851969</span>;</span><br><span class="line">        formatPrintInt(state);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sharedCount=sharedCount(state);</span><br><span class="line">        logger.info(<span class="string">&quot;sharedCount=&#123;&#125;&quot;</span>,sharedCount);</span><br><span class="line">        formatPrintInt(sharedCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> exclusiveCount=exclusiveCount(state);</span><br><span class="line">        logger.info(<span class="string">&quot;exclusiveCount=&#123;&#125;&quot;</span>,exclusiveCount);</span><br><span class="line">        formatPrintInt(exclusiveCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">formatPrintInt</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;num=&#123;&#125;,upper16=&#123;&#125;,lower16=&#123;&#125;&quot;</span>,num, StringUtils.leftPad(Integer.toBinaryString(num), <span class="number">32</span>, <span class="string">&quot;0&quot;</span>).substring(<span class="number">0</span>,<span class="number">16</span>),StringUtils.leftPad(Integer.toBinaryString(num), <span class="number">32</span>, <span class="string">&quot;0&quot;</span>).substring(<span class="number">16</span>) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>线程本地变量</strong><br>继续看<code>Sync</code>代码下面的部分，可以看到<code>4</code>个成员变量，这几个变量的作用主要是将获取读锁的线程放入线程本地变量，方便从整个上下文根据当前线程获取持有锁的次数信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread firstReader = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> firstReaderHoldCount;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中<code>firstReader</code>与<code>firstReadHoldCount</code>保存第一个获取读锁的线程的信息。<br><code>cachedHoldCounter</code>用来缓存的是最后一个获取线程的<code>HolderCount</code>信息，该变量主要是在如果当前线程多次获取读锁时，减少从<code>readHolds</code>中获取<code>HoldCounter</code>的次数。<br><strong>写锁的获取</strong><br>写锁的获取通过调用<code>WriteLock</code>的<code>lock()</code>方法<br>        public void lock() {<br>            sync.acquire(1);<br>        }<br>进而调用<code>AbstractQueuedSynchronizer</code>的<code>acquire()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而<code>tryAcquire()</code>方法是由<code>AQS</code>的子类，即上面提到过的<code>ReentrantReadWriteLock</code>的内部<code>Sync</code>去实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">	<span class="comment">//1.即读锁或者写锁数量不为0</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">		*2.w=0即没有写锁，而state不为0，故读锁被占用</span></span><br><span class="line"><span class="comment">		*或者写锁被其他线程持有,返回false</span></span><br><span class="line"><span class="comment">		*/</span>			</span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="comment">//3.写锁计数将会越界，即大于65535，抛出异常，返回false</span></span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">//4.这里表示写锁不是0，并且当前线程持有锁，即重入，故修改写锁的数量即可</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//如果通过一次CAS去获取锁的时候失败，说明被别的线程占用，也返回false,排队去重试获取锁。	</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果<code>tryAcquire</code>方法返回为<code>true</code>,则尝试获取锁方法结束。如果该方法返回<code>false</code>,则进入到<code>acquireQueue</code>方法去排队获取写锁，排队获取写锁的过程和<code>ReentrantLock</code>的获取过程一样。<br>通过写锁的获取过程，我们知道   </p>
<ul>
<li>如果当前没有写锁或者读锁，第一个获取锁的线程会获取成功不管是获得写锁还是读锁</li>
<li>如果当前已经有了读锁，则获取写锁会失败，而获取读锁有可能成功也可能失败</li>
<li>如果当前已经有了写锁，则如果写锁的持有者为当前线程，由于锁可重入，则获取读锁或者写锁可成功；反之如果写锁的持有者不是当前线程，则失败。</li>
</ul>
<p><strong>写锁的释放</strong><br>释放锁要做的事情是将<code>AQS</code>中的<code>state</code>值进行修改，并唤醒队列中的等待线程来获取锁。<br><code>WriteLock</code>通过调用<code>unlock()</code>方法 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>Sync</code>中的<code>release</code>方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>Sync</code>作为<code>AQS</code>的子类，自己要去实现<code>tryRelease()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果写锁的持有者并非当前线程，抛出异常</span></span><br><span class="line">	<span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">    <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//如果释放锁后，写锁数据(state高16位)为0，则free返回为true,同时将AQS的写锁持有者线程置null，更改state的值。否则返回为false。</span></span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果<code>tryRelease</code>方法成功释放锁，则需要调用<code>unparkSuccessor()</code>方法去唤醒等待队列中线程，并修改状态值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到仅当写锁的持有者为当前线程，并且释放锁后的写锁数据为<code>0</code>才认为成功释放写锁。   </p>
<p><strong>读锁的获取</strong><br>读锁的获取过程比写锁相对复杂一些，使用读锁时，先调用<code>ReadLock</code>的<code>lock()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用<code>AQS</code>的共享模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>tryAcquireShared</code>方法的实现还是在<code>Sync</code>中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;			 </span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">//如果写锁被其他线程持有，直接返回-1</span></span><br><span class="line">	<span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">	<span class="comment">//读锁线程不需要阻塞，并且获取读锁的线程数没有超过最大值，并且使用 CAS更新共享锁线程数量成功，则设置线程本地变量信息，否则调用fullTryAcquireShared()方法</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">		<span class="comment">//r==0，表示当前线程为第一个获取读锁的线程，更新firstReader和firstReaderHoldCount</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">		<span class="comment">//如果firstReader是当前线程，则更新firstReaderHoldCount，即读锁重入</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">		<span class="comment">//如果firstReader不是当前线程，则将该线程持有锁的次数信息放入线程本地变量中，方便整个请求上下文中使用	</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们先看看<code>fullTryAcquireShared</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">    HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">		<span class="comment">//如果当前线程不是写锁的持有者，返回-1，获取读锁失败。需要排队去申请读锁</span></span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// else we hold the exclusive lock; blocking here</span></span><br><span class="line">            <span class="comment">// would cause deadlock.</span></span><br><span class="line">		<span class="comment">//读线程需要阻塞，具体见readerShouldBlock的分析</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">            <span class="comment">// Make sure we&#x27;re not acquiring read lock reentrantly</span></span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//读锁别其他线程占用，从readHolds中移除当前线程的持有数，返回-1，获取读锁失败。需要排队去申请读锁</span></span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            readHolds.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">		<span class="comment">//尝试获取锁成功的话则更新readHolds内部变量</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                firstReader = current;</span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                rh.count++;</span><br><span class="line">                cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中读锁或者是否需要阻塞，是区分公平锁和非公平锁的关键。以读锁为例，非公平锁<code>NonfairSync</code>的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">apparentlyFirstQueuedIsExclusive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node h, s;</span><br><span class="line">    <span class="keyword">return</span> (h = head) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (s = h.next)  != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        !s.isShared()         &amp;&amp;</span><br><span class="line">        s.thread != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>公平锁的实现如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">    <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">    <span class="comment">// thread is first in queue.</span></span><br><span class="line">    Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于公平锁，只要队列中有线程在等待，那么将会返回<code>true</code>，也就意味着读线程需要阻塞；对于非公平锁，如果当前线程持有写锁外，还有其他线程已经排队在申请写锁，则只能结束本次申请读锁的请求，转而去排队。这样处理，主要是避免写锁无限期的饥饿(<code>avoid</code> <code>indefinite</code> <code>writer</code> <code>starvation</code>)。<br>一旦不阻塞，那么读线程将会有机会获得读锁。<br>完成尝试获取锁步骤 <code>tryAcquireShared</code> 方法后，我们再次回到 <code>acquireShared</code>，如果返回<code>1</code>则读锁获取成功。如果返回-<code>1</code>,则需要排队申请,具体请看 <code>doAcquireShared</code>(<code>arg</code>)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//根据当前线程构建Node,并添加到队列尾部</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">			<span class="comment">//获取节点的前置节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//如果前置节点是head时，再次尝试获取锁(因为head节点的初始化在第一次产生锁争用时初始化，刚开始初始化的head节点不代表线程，故可以再次尝试获取锁)。如果获取失败则进入到shouldParkAfterFailedAcquire和parkAndCheckInterrupt方法中，线程阻塞，等待被唤醒。</span></span><br><span class="line">			<span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="comment">//如果锁获取成功，则设置head节点并传播</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所谓传播，只要获取成功到读锁，那就要传播到下一个节点。如果一下个节点继续是读锁的申请，只要成功获取，就再下一个节点，直到队列尾部或为写锁的申请，则停止传播。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">		Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">		setHead(node);			<span class="comment">//如果读锁获取成功，或头部节点为空，或头节点取消，或刚获取读锁的线程的下一个节点为空，或在节点的下个节点也在申请读锁，则在CLH队列中传播下去唤醒线程</span></span><br><span class="line">		<span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">			(h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			Node s = node.next;</span><br><span class="line">			<span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">				doReleaseShared();</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    head = node;</span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line">    node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>读锁的释放</strong><br>读锁的释放比较简单，调用<code>ReadLock</code>的<code>unlock</code>方法，进而调用<code>Sync</code>的<code>releaseShared</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>releaseShared</code>方法主要是释放减少读锁<code>state</code>的值，直到完全释放后，进行<code>doReleaseShared()</code>操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>tryReleaseShared()</code>方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">	<span class="comment">//主要是将当前线程所持有的锁的数量信息得到（从firstReader或cachedHoldCounter，或readHolds中获取 ），然后将数量减少1,如果持有数为1，则直接将该线程变量从readHolds ThreadLocal变量中移除，避免垃圾堆积。</span></span><br><span class="line">    <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">        <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">        <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">            firstReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            firstReaderHoldCount--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">            rh = readHolds.get();</span><br><span class="line">        <span class="keyword">int</span> count = rh.count;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            readHolds.remove();</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        --rh.count;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//在无限循环中将共享锁的数量逐步减少，直到该读锁state为0(低16位)。释放完成后去执行doReleaseShared方法。</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="comment">// Releasing the read lock has no effect on readers,</span></span><br><span class="line">            <span class="comment">// but it may allow waiting writers to proceed if</span></span><br><span class="line">            <span class="comment">// both read and write locks are now free.</span></span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>至此，<code>ReentrantReadWriteLock</code>锁的分析到此结束。</p>
<p>本文主要以一个账户余额管理的示例，引入锁的概念及相关实现，主要包括Java内存模型、同步块、重入锁<code>ReentrantLock</code>和读写锁<code>ReentrantReadWriteLock</code>的应用及源码实现。</p>
<p>本文参考</p>
<p><a target="_blank" rel="noopener" href="http://it-ebooks.info/book/3916/">Java 7 Concurrency Cookbook</a></p>
<p><a target="_blank" rel="noopener" href="http://ifeve.com/concurrency-modle-seven-week-1/">concurrency-modle-seven-week</a></p>
<p><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/concurrency-models.html">java-concurrency</a></p>
<p><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-util-concurrent/lock.html">java-util-concurrent</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/">java se 8 apidoc</a></p>
<hr>
<p>关于作者<br>爱编程、爱钻研、爱分享、爱生活<br>关注分布式、高并发、数据挖掘<br>如需捐赠，请扫码<br><img src="https://raw.githubusercontent.com/aidodoo/blogpic/master/sqm/sqm.jpg" width=256 height=256 /></p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://aidodoo.com/java/java%E5%B9%B6%E5%8F%91-%E5%90%8C%E6%AD%A5%E5%92%8C%E9%94%81/" title="同步和锁" target="_blank" rel="external">http://aidodoo.com/java/java并发-同步和锁/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/aidodoo" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/aidodoo" target="_blank"><span class="text-dark">aidodoo</span><small class="ml-1x">Java Developer</small></a></h3>
        <div>爱编程、爱钻研、爱分享、爱生活。关注分布式、高并发、数据挖掘</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/java/java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB1/" title="并发工具类一"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;Newer</span></a>
    </li>
    
    
    <li class="next">
      <a href="/java/java%E5%B9%B6%E5%8F%91-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%92%8CThread/" title="JAVA并发概念、基础接口以及Thread"><span>Older&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>$</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>Maybe you could buy me a cup of coffee.</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="Scan Qrcode" title="Scan" />
              </div>
              <p class="text-muted mv">Scan this qrcode</p>
              <p class="text-grey">Open alipay app scan this qrcode, buy me a coffee!</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="Scan Qrcode" title="Scan" />
              </div>
              <p class="text-muted mv">Scan this qrcode</p>
              <p class="text-grey">Open wechat app scan this qrcode, buy me a coffee!</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> alipay</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> wechat payment</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/aidodoo" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com/aidodoo" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>



    <script>
(function ($) {
    $('.search-form').on('submit', function (e) {
        var keyword = $('.search-form-input[name="wd"]').val();
        window.location = 'https://www.baidu.com/s?wd=site:aidodoo.com ' + keyword;
        return false;
    });
})(jQuery);
</script>




   




   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '',
    appKey: '',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>